<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>资本杀 Tiny 版</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background-color: #f0f2f5;
            color: #333;
            margin: 0;
            padding: 20px;
        }
        .game-container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #2d3436;
            margin-bottom: 30px;
        }
        .status-area {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #dfe6e9;
            border-radius: 8px;
        }
        .player-area {
            margin: 20px 0;
            padding: 15px;
            border: 2px solid #b2bec3;
            border-radius: 8px;
            background-color: #f7f7f7;
        }
        .current-player {
            border-color: #6c5ce7;
            background-color: #e8e6ff;
        }
        .card-item {
            display: inline-block;
            width: 80px;
            height: 120px;
            border: 1px solid #bbb;
            border-radius: 8px;
            margin: 5px;
            padding: 10px;
            text-align: center;
            vertical-align: top;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            cursor: pointer;
            position: relative;
        }
        .card-spade, .card-club {
            background-color: #ffeaa7;
            border-color: #fdcb6e;
        }
        .card-heart {
            background-color: #ff7675;
            color: white;
        }
        .card-diamond {
            background-color: #74b9ff;
            color: white;
        }
        .card-joker {
            background-color: #00b894;
            color: white;
        }
        .card-value {
            font-size: 1.2em;
            font-weight: bold;
            position: absolute;
            top: 5px;
            left: 5px;
        }
        .card-type {
            font-size: 2em;
            line-height: 80px;
        }
        .controls {
            margin: 20px 0;
            text-align: center;
        }
        .game-button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #6c5ce7;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.3s;
        }
        .game-button:hover {
            background-color: #5649c1;
        }
        .game-button:disabled {
            background-color: #b2bec3;
            cursor: not-allowed;
        }
        .action-area {
            margin: 20px 0;
            padding: 15px;
            background-color: #eee;
            border-radius: 8px;
        }
        .game-log {
            height: 200px;
            overflow-y: auto;
            padding: 10px;
            background-color: #2d3436;
            color: white;
            border-radius: 8px;
            margin-top: 20px;
            font-family: monospace;
        }
        .log-entry {
            margin: 5px 0;
            padding: 3px;
            border-bottom: 1px solid #636e72;
        }
        .info-box {
            margin: 10px 0;
            padding: 10px;
            background-color: #dff0d8;
            border-left: 4px solid #5cb85c;
            border-radius: 4px;
        }
        .bid-buttons, .attack-buttons, .defend-buttons, .pay-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        .leverage-selection {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        #player-area-template {
            display: none;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>资本杀 Tiny 版 @Polaris. New</h1>
        
        <div class="status-area">
            <div class="game-status">
                <p>牌堆剩余: <span id="deck-count">52</span> 张</p>
                <p>当前回合: <span id="current-turn">-</span></p>
                <p>游戏阶段: <span id="game-phase">准备中</span></p>
            </div>
            <div class="player-status">
                <p>总玩家: <span id="player-count">0</span></p>
                <p>出局玩家: <span id="out-count">0</span></p>
            </div>
        </div>
        
        <div class="player-area" id="player-area-template">
            <h3>玩家 <span class="player-id">1</span></h3>
            <p>现金牌: <span class="cash-count">0</span></p>
            <div class="player-cards"></div>
        </div>
        
        <div class="action-area" id="action-area">
            <!-- 动态填充的操作区域 -->
        </div>
        
        <div class="controls">
            <button class="game-button" id="btn-start">开始游戏</button>
            <button class="game-button" id="btn-new" disabled>新游戏</button>
        </div>
        
        <div class="game-log">
            <div id="game-log">
                <div class="log-entry">游戏日志将会显示在这里...</div>
            </div>
        </div>
    </div>

    <script>
        // 游戏常量
        const CARD_TYPES = {
            SPADE: '♠️',    // 现金牌
            CLUB: '♣️',     // 现金牌
            HEART: '♥️',    // 吃牌
            DIAMOND: '♦️',  // 挡牌
            BIG_JOKER: '大王', // 全局吃牌
            SMALL_JOKER: '小王' // 全局吃牌
        };

        const GAME_STATES = {
            INIT: 'init',
            BIDDING: 'bidding',
            PLAYING: 'playing',
            ATTACKING: 'attacking',
            DEFENDING: 'defending',
            PAYING: 'paying',
            GAME_OVER: 'game_over'
        };

        // 游戏核心类
        class CapitalKillTiny {
            constructor() {
                this.players = [];
                this.deck = [];
                this.discardPile = [];
                this.currentPlayerIndex = 0;
                this.currentState = GAME_STATES.INIT;
                this.attackTarget = null;
                this.leverage = 0;
                this.bidRecords = {};
                this.attackCard = null;
                this.logEntries = [];
                this.globalAttackQueue = [];
            }
            
            // 初始化游戏
            initGame(playerCount = 3) {
                this.players = [];
                this.deck = this.createDeck();
                this.shuffleDeck();
                this.discardPile = [];
                this.logEntries = [];
                this.currentState = GAME_STATES.INIT;
                this.globalAttackQueue = [];
                
                // 创建玩家
                for (let i = 0; i < playerCount; i++) {
                    this.players.push({
                        id: i + 1,
                        hand: [],
                        cashCards: [],
                        isOut: false
                    });
                }
                
                // 发牌
                this.dealCards(7);
                
                this.addLog(`游戏初始化完成，${playerCount}位玩家准备就绪`);
                this.renderGame();
                return this;
            }
            
            // 创建牌组
            createDeck() {
                const deck = [];
                
                // 创建普通牌
                const suits = [CARD_TYPES.SPADE, CARD_TYPES.CLUB, 
                              CARD_TYPES.HEART, CARD_TYPES.DIAMOND];
                const values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
                
                for (const suit of suits) {
                    for (const value of values) {
                        deck.push({ suit, value, type: this.getCardType(suit) });
                    }
                }
                
                // 添加大小王
                deck.push({ suit: CARD_TYPES.BIG_JOKER, value: '大王', type: 'global', attack: 2 });
                deck.push({ suit: CARD_TYPES.SMALL_JOKER, value: '小王', type: 'global', attack: 1 });
                
                return deck;
            }
            
            // 获取卡牌类型
            getCardType(suit) {
                switch(suit) {
                    case CARD_TYPES.SPADE:
                    case CARD_TYPES.CLUB:
                        return 'cash';
                    case CARD_TYPES.HEART:
                        return 'attack';
                    case CARD_TYPES.DIAMOND:
                        return 'defense';
                    case CARD_TYPES.BIG_JOKER:
                    case CARD_TYPES.SMALL_JOKER:
                        return 'global';
                    default:
                        return 'unknown';
                }
            }
            
            // 洗牌
            shuffleDeck() {
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
            }
            
            // 发牌
            dealCards(cardsPerPlayer) {
                for (let i = 0; i < cardsPerPlayer; i++) {
                    for (const player of this.players) {
                        if (this.deck.length > 0) {
                            player.hand.push(this.deck.pop());
                        }
                    }
                }
                
                // 更新玩家现金牌信息
                for (const player of this.players) {
                    player.cashCards = player.hand.filter(card => card.type === 'cash');
                }
            }
            
            // 开始游戏
            startGame() {
                if (this.currentState !== GAME_STATES.INIT) {
                    return;
                }
                
                this.currentState = GAME_STATES.BIDDING;
                this.addLog("游戏开始！请玩家质押现金牌竞拍先手权");
                this.renderGame();
            }
            
            // 玩家竞拍
            playerBid(playerId, bidAmount) {
                if (this.currentState !== GAME_STATES.BIDDING) {
                    return;
                }
                
                const player = this.players.find(p => p.id === playerId);
                if (!player || bidAmount > player.cashCards.length) {
                    return;
                }
                
                this.bidRecords[playerId] = bidAmount;
                this.addLog(`玩家 ${playerId} 出价 ${bidAmount} 张现金牌`);
                
                // 检查是否所有玩家都已完成竞拍
                if (Object.keys(this.bidRecords).length === this.players.length) {
                    this.determineFirstPlayer();
                }
                
                this.renderGame();
            }
            
            // 确定先手玩家
            determineFirstPlayer() {
                let maxBid = -1;
                let firstPlayer = null;
                
                for (const [playerId, bid] of Object.entries(this.bidRecords)) {
                    if (bid > maxBid) {
                        maxBid = bid;
                        firstPlayer = parseInt(playerId);
                    }
                }
                
                // 找到当前玩家的索引
                this.currentPlayerIndex = this.players.findIndex(p => p.id === firstPlayer);
                const player = this.players[this.currentPlayerIndex];
                
                // 从手牌中移除质押的现金牌
                let bidPaid = 0;
                for (let i = player.hand.length - 1; i >= 0 && bidPaid < maxBid; i--) {
                    if (player.hand[i].type === 'cash') {
                        this.discardPile.push(player.hand[i]);
                        player.hand.splice(i, 1);
                        bidPaid++;
                    }
                }
                
                // 更新玩家现金牌信息
                player.cashCards = player.hand.filter(card => card.type === 'cash');
                
                this.addLog(`玩家 ${player.id} 以 ${maxBid} 张现金牌赢得先手权`);
                this.currentState = GAME_STATES.PLAYING;
                this.playerTurn();
                this.renderGame();
            }
            
            // 玩家回合
            playerTurn() {
                if (this.currentState !== GAME_STATES.PLAYING) {
                    return;
                }
                
                const player = this.players[this.currentPlayerIndex];
                this.addLog(`玩家 ${player.id} 的回合开始`);
                
                // 抽牌阶段
                if (this.deck.length > 0) {
                    player.hand.push(this.deck.pop());
                    this.addLog(`玩家 ${player.id} 抽了一张牌`);
                } else {
                    this.addLog(`牌堆已空，玩家 ${player.id} 未能抽牌`);
                }
                
                // 更新玩家现金牌信息
                player.cashCards = player.hand.filter(card => card.type === 'cash');
                this.renderGame();
            }
            
            // 玩家出牌
            playerPlayCard(playerId, cardIndex, leverageCount = 0) {
                if (this.currentState !== GAME_STATES.PLAYING) {
                    return false;
                }
                
                const player = this.players.find(p => p.id === playerId);
                if (!player || player.id !== this.players[this.currentPlayerIndex].id) {
                    return false;
                }
                
                if (cardIndex < 0 || cardIndex >= player.hand.length) {
                    return false;
                }
                
                const card = player.hand[cardIndex];
                if (!card) {
                    return false;
                }
                
                // 移除玩家手牌
                player.hand.splice(cardIndex, 1);
                
                // 根据卡牌类型处理
                switch(card.type) {
                    case 'cash':
                        this.discardPile.push(card);
                        this.addLog(`玩家 ${playerId} 弃置了一张现金牌`);
                        this.endTurn();
                        return true;
                        
                    case 'defense':
                        this.discardPile.push(card);
                        this.addLog(`玩家 ${playerId} 弃置了一张挡牌`);
                        this.endTurn();
                        return true;
                        
                    case 'attack':
                        this.attackCard = card;
                        this.leverage = leverageCount;
                        this.currentState = GAME_STATES.ATTACKING;
                        this.addLog(`玩家 ${playerId} 使用了吃牌进攻，${leverageCount ? `附带 ${leverageCount} 张杠杆` : ''}`);
                        this.renderGame();
                        return true;
                        
                    case 'global':
                        this.attackCard = card;
                        this.currentState = GAME_STATES.ATTACKING;
                        this.addLog(`玩家 ${playerId} 使用了 ${card.value} 进攻`);
                        this.renderGame();
                        return true;
                }
                
                return false;
            }
            
            // 玩家防御
            playerDefend(playerId, defend) {
                if (this.currentState !== GAME_STATES.DEFENDING) {
                    return false;
                }
                
                const player = this.players.find(p => p.id === playerId);
                if (!player || player.id !== this.attackTarget) {
                    return false;
                }
                
                if (defend) {
                    // 找出玩家手上的挡牌
                    const defendCardIndex = player.hand.findIndex(card => card.type === 'defense');
                    
                    if (defendCardIndex === -1) {
                        this.addLog(`玩家 ${playerId} 没有挡牌防御`);
                        return false;
                    }
                    
                    const defendCard = player.hand.splice(defendCardIndex, 1)[0];
                    this.discardPile.push(defendCard);
                    
                    // 防御成功，防守方获得进攻方的杠杆牌
                    const attacker = this.players.find(p => p.id === this.players[this.currentPlayerIndex].id);
                    for (let i = 0; i < this.leverage && attacker.cashCards.length > 0; i++) {
                        const cashIndex = attacker.hand.findIndex(card => card.type === 'cash');
                        if (cashIndex >= 0) {
                            player.hand.push(attacker.hand.splice(cashIndex, 1)[0]);
                        }
                    }
                    
                    this.addLog(`玩家 ${playerId} 成功防御！获得 ${this.leverage} 张杠杆牌`);
                    this.leverage = 0;
                    this.attackCard = null;
                    
                    // 处理全局攻击队列
                    if (this.globalAttackQueue.length > 0) {
                        this.nextGlobalAttackTarget();
                    } else {
                        this.currentState = GAME_STATES.PLAYING;
                        this.endTurn();
                    }
                    return true;
                } else {
                    // 防御失败，进入支付阶段
                    this.currentState = GAME_STATES.PAYING;
                    this.addLog(`玩家 ${playerId} 放弃防御，进入支付阶段`);
                    this.renderGame();
                    return true;
                }
            }
            
            // 玩家支付
            playerPay(playerId, paymentType) {
                if (this.currentState !== GAME_STATES.PAYING) {
                    return false;
                }
                
                const player = this.players.find(p => p.id === playerId);
                if (!player || player.id !== this.attackTarget) {
                    return false;
                }
                
                const requiredCards = 1 + this.leverage;
                
                // 检查玩家是否能够支付
                if (player.hand.length < requiredCards) {
                    player.isOut = true;
                    // 出局玩家弃置所有手牌
                    player.hand.forEach(card => this.discardPile.push(card));
                    player.hand = [];
                    this.addLog(`玩家 ${playerId} 无法支付，宣告出局！`);
                    this.currentState = GAME_STATES.PLAYING;
                    
                    // 处理全局攻击队列
                    if (this.globalAttackQueue.length > 0) {
                        this.nextGlobalAttackTarget();
                    } else {
                        // 检查游戏是否结束
                        const activePlayers = this.players.filter(p => !p.isOut);
                        if (activePlayers.length <= 1 || this.deck.length === 0) {
                            this.endGame();
                        } else {
                            this.endTurn();
                        }
                    }
                    return true;
                }
                
                // 处理不同类型的支付
                switch(paymentType) {
                    case 'cash': // 献上现金牌
                        for (let i = 0; i < requiredCards; i++) {
                            const attacker = this.players.find(p => p.id === this.players[this.currentPlayerIndex].id);
                            const cashIndex = player.hand.findIndex(card => card.type === 'cash');
                            
                            if (cashIndex >= 0) {
                                attacker.hand.push(player.hand.splice(cashIndex, 1)[0]);
                            } else {
                                // 现金牌不足，转为盲抽
                                const randomIndex = Math.floor(Math.random() * player.hand.length);
                                attacker.hand.push(player.hand.splice(randomIndex, 1)[0]);
                            }
                        }
                        this.addLog(`玩家 ${playerId} 献上 ${requiredCards} 张现金牌`);
                        break;
                        
                    case 'blind': // 盲抽
                        for (let i = 0; i < requiredCards; i++) {
                            const attacker = this.players.find(p => p.id === this.players[this.currentPlayerIndex].id);
                            const randomIndex = Math.floor(Math.random() * player.hand.length);
                            attacker.hand.push(player.hand.splice(randomIndex, 1)[0]);
                        }
                        this.addLog(`玩家 ${playerId} 被盲抽 ${requiredCards} 张牌`);
                        break;
                        
                    case 'mixed': // 混合支付
                        // 先尽量给现金牌
                        let cashPaid = 0;
                        for (let i = player.hand.length - 1; i >= 0 && cashPaid < Math.floor(requiredCards / 2); i--) {
                            if (player.hand[i].type === 'cash') {
                                const attacker = this.players.find(p => p.id === this.players[this.currentPlayerIndex].id);
                                attacker.hand.push(player.hand.splice(i, 1)[0]);
                                cashPaid++;
                            }
                        }
                        
                        // 剩余用盲抽
                        for (let i = cashPaid; i < requiredCards; i++) {
                            const attacker = this.players.find(p => p.id === this.players[this.currentPlayerIndex].id);
                            const randomIndex = Math.floor(Math.random() * player.hand.length);
                            attacker.hand.push(player.hand.splice(randomIndex, 1)[0]);
                        }
                        this.addLog(`玩家 ${playerId} 混合支付 ${requiredCards} 张牌`);
                        break;
                }
                
                // 结束支付阶段
                this.leverage = 0;
                this.attackCard = null;
                
                // 处理全局攻击队列
                if (this.globalAttackQueue.length > 0) {
                    this.nextGlobalAttackTarget();
                } else {
                    this.currentState = GAME_STATES.PLAYING;
                    this.endTurn();
                }
                return true;
            }
            
            // 处理下一个全局攻击目标
            nextGlobalAttackTarget() {
                if (this.globalAttackQueue.length === 0) {
                    this.currentState = GAME_STATES.PLAYING;
                    this.endTurn();
                    return;
                }
                
                const nextTarget = this.globalAttackQueue.shift();
                this.attackTarget = nextTarget;
                this.currentState = GAME_STATES.DEFENDING;
                this.addLog(`玩家 ${nextTarget} 成为攻击目标`);
                this.renderGame();
            }
            
            // 结束回合
            endTurn() {
                // 寻找下一个活跃玩家
                let nextPlayerIndex = this.currentPlayerIndex;
                do {
                    nextPlayerIndex = (nextPlayerIndex + 1) % this.players.length;
                    
                    // 检查所有玩家都出局的情况
                    let activePlayers = this.players.filter(p => !p.isOut);
                    if (activePlayers.length === 0) {
                        this.endGame();
                        return;
                    }
                } while (this.players[nextPlayerIndex].isOut);
                
                this.currentPlayerIndex = nextPlayerIndex;
                this.playerTurn();
            }
            
            // 游戏结束
            endGame() {
                this.currentState = GAME_STATES.GAME_OVER;
                this.addLog("游戏结束！");
                
                // 计算每位玩家的现金牌数量
                const results = this.players.map(player => ({
                    playerId: player.id,
                    cashCount: player.hand.filter(card => card.type === 'cash').length
                })).sort((a, b) => b.cashCount - a.cashCount);
                
                // 添加游戏结果
                this.addLog("<div class='log-result'>最终结果：</div>");
                results.forEach((result, index) => {
                    const place = index === 0 ? '冠军' : `第${index + 1}名`;
                    this.addLog(`<div class='log-result'>玩家 ${result.playerId} ${place}（现金牌: ${result.cashCount}）</div>`);
                });
                
                this.renderGame();
            }
            
            // 添加游戏日志
            addLog(message) {
                this.logEntries.push({
                    timestamp: new Date(),
                    message
                });
                
                if (this.logEntries.length > 50) {
                    this.logEntries.shift();
                }
                
                this.renderLog();
            }
            
            // 渲染日志
            renderLog() {
                const logElement = document.getElementById('game-log');
                if (!logElement) return;
                
                logElement.innerHTML = '';
                this.logEntries.forEach(entry => {
                    const logEntry = document.createElement('div');
                    logEntry.className = 'log-entry';
                    logEntry.innerHTML = `[${entry.timestamp.toLocaleTimeString()}] ${entry.message}`;
                    logElement.appendChild(logEntry);
                });
                
                // 滚动到底部
                logElement.scrollTop = logElement.scrollHeight;
            }
            
            // 渲染游戏状态
            renderGame() {
                const deckCount = document.getElementById('deck-count');
                const currentTurn = document.getElementById('current-turn');
                const gamePhase = document.getElementById('game-phase');
                const playerCount = document.getElementById('player-count');
                const outCount = document.getElementById('out-count');
                
                if (deckCount) deckCount.textContent = String(this.deck.length);
                if (currentTurn && this.players[this.currentPlayerIndex]) {
                    currentTurn.textContent = String(this.players[this.currentPlayerIndex].id);
                }
                if (gamePhase) {
                    let phaseText = '';
                    switch(this.currentState) {
                        case GAME_STATES.INIT: phaseText = '准备中'; break;
                        case GAME_STATES.BIDDING: phaseText = '竞拍阶段'; break;
                        case GAME_STATES.PLAYING: phaseText = '游戏进行中'; break;
                        case GAME_STATES.ATTACKING: phaseText = '进攻阶段'; break;
                        case GAME_STATES.DEFENDING: phaseText = '防御阶段'; break;
                        case GAME_STATES.PAYING: phaseText = '支付阶段'; break;
                        case GAME_STATES.GAME_OVER: phaseText = '游戏结束'; break;
                    }
                    gamePhase.textContent = phaseText;
                }
                if (playerCount) playerCount.textContent = String(this.players.length);
                if (outCount) outCount.textContent = String(this.players.filter(p => p.isOut).length);
                
                // 渲染玩家区域
                const playersArea = document.querySelectorAll('.player-area');
                playersArea.forEach(playerArea => {
                    if (playerArea.id !== 'player-area-template') {
                        playerArea.remove();
                    }
                });
                
                // 反转玩家顺序 (1,2,3)
                const reversedPlayers = [...this.players].reverse();
                
                reversedPlayers.forEach((player, index) => {
                    const template = document.getElementById('player-area-template');
                    const clone = template.cloneNode(true);
                    clone.id = `player-area-${player.id}`;
                    clone.style.display = 'block';
                    
                    if (player.id === this.players[this.currentPlayerIndex].id) {
                        clone.classList.add('current-player');
                    }
                    
                    // 设置玩家信息
                    clone.querySelector('.player-id').textContent = String(player.id);
                    clone.querySelector('.cash-count').textContent = String(player.hand.filter(card => card.type === 'cash').length);
                    
                    // 渲染手牌
                    const cardsContainer = clone.querySelector('.player-cards');
                    cardsContainer.innerHTML = '';
                    
                    player.hand.forEach((card, cardIndex) => {
                        const cardElement = document.createElement('div');
                        cardElement.className = `card-item ${this.getCardClass(card)}`;
                        cardElement.innerHTML = `
                            <div class="card-value">${card.value}</div>
                            <div class="card-type">${card.suit}</div>
                        `;
                        cardElement.dataset.cardIndex = cardIndex;
                        
                        // 添加点击事件（仅限于当前玩家和相应游戏状态）
                        if (player.id === this.players[this.currentPlayerIndex].id) {
                            if (this.currentState === GAME_STATES.PLAYING || 
                                this.currentState === GAME_STATES.ATTACKING) {
                                cardElement.addEventListener('click', () => this.handleCardClick(player, cardIndex));
                            }
                        }
                        
                        cardsContainer.appendChild(cardElement);
                    });
                    
                    template.parentNode.insertBefore(clone, template.nextSibling);
                });
                
                // 渲染操作区域
                this.renderActionArea();
                this.renderLog();
            }
            
            // 获取卡片CSS类
            getCardClass(card) {
                switch(card.suit) {
                    case CARD_TYPES.SPADE: return 'card-spade';
                    case CARD_TYPES.CLUB: return 'card-club';
                    case CARD_TYPES.HEART: return 'card-heart';
                    case CARD_TYPES.DIAMOND: return 'card-diamond';
                    case CARD_TYPES.BIG_JOKER:
                    case CARD_TYPES.SMALL_JOKER: return 'card-joker';
                    default: return '';
                }
            }
            
            // 渲染操作区域
            renderActionArea() {
                const actionArea = document.getElementById('action-area');
                if (!actionArea) return;
                
                actionArea.innerHTML = '';
                
                // 根据游戏状态渲染不同的操作界面
                switch(this.currentState) {
                    case GAME_STATES.BIDDING:
                        const bidContainer = document.createElement('div');
                        bidContainer.className = 'info-box';
                        bidContainer.innerHTML = '<h3>先手权竞拍</h3><p>请所有玩家质押现金牌竞拍先手权</p>';
                        actionArea.appendChild(bidContainer);
                        
                        const bidButtons = document.createElement('div');
                        bidButtons.className = 'bid-buttons';
                        
                        const bidderPlayer = this.players[Object.keys(this.bidRecords).length];
                        if (bidderPlayer) {
                            const maxBid = bidderPlayer.cashCards.length;
                            
                            for (let i = 0; i <= maxBid; i++) {
                                const button = document.createElement('button');
                                button.className = 'game-button';
                                button.textContent = `出价 ${i} 张`;
                                button.dataset.bidAmount = i;
                                button.addEventListener('click', () => {
                                    this.playerBid(bidderPlayer.id, i);
                                });
                                bidButtons.appendChild(button);
                            }
                            
                            actionArea.appendChild(bidButtons);
                        }
                        break;
                    
                    case GAME_STATES.ATTACKING:
                        const attackContainer = document.createElement('div');
                        attackContainer.className = 'info-box';
                        attackContainer.innerHTML = '<h3>进攻阶段</h3><p>请选择攻击目标：</p>';
                        actionArea.appendChild(attackContainer);
                        
                        const attackButtons = document.createElement('div');
                        attackButtons.className = 'attack-buttons';
                        
                        this.players.forEach(player => {
                            if (player.id !== this.players[this.currentPlayerIndex].id && !player.isOut) {
                                const button = document.createElement('button');
                                button.className = 'game-button';
                                button.textContent = `玩家 ${player.id}`;
                                button.addEventListener('click', () => this.handleAttackTarget(player.id));
                                attackButtons.appendChild(button);
                            }
                        });
                        
                        // 如果是全局攻击卡，可以选择所有玩家
                        if (this.attackCard?.suit === CARD_TYPES.BIG_JOKER || 
                            this.attackCard?.suit === CARD_TYPES.SMALL_JOKER) {
                            const button = document.createElement('button');
                            button.className = 'game-button';
                            button.textContent = '所有玩家';
                            button.addEventListener('click', () => this.handleAttackTarget('all'));
                            attackButtons.appendChild(button);
                        }
                        
                        actionArea.appendChild(attackButtons);
                        break;
                    
                    case GAME_STATES.DEFENDING:
                        const defenderPlayer = this.players.find(p => p.id === this.attackTarget);
                        if (!defenderPlayer) break;
                        
                        const defendContainer = document.createElement('div');
                        defendContainer.className = 'info-box';
                        defendContainer.innerHTML = `<h3>防御阶段 - 玩家 ${defenderPlayer.id}</h3>
                            <p>攻击强度：${this.attackCard?.suit === '♥️' ? '1+' + this.leverage : this.attackCard?.value === '大王' ? 2 : 1}</p>
                            <p>请选择是否防御：</p>`;
                        actionArea.appendChild(defendContainer);
                        
                        const defendButtons = document.createElement('div');
                        defendButtons.className = 'defend-buttons';
                        
                        // 检查是否有挡牌
                        const canDefend = defenderPlayer.hand.some(card => card.type === 'defense');
                        
                        if (canDefend) {
                            const defendButton = document.createElement('button');
                            defendButton.className = 'game-button';
                            defendButton.textContent = '使用挡牌防御';
                            defendButton.addEventListener('click', () => this.playerDefend(defenderPlayer.id, true));
                            defendButtons.appendChild(defendButton);
                        }
                        
                        const notDefendButton = document.createElement('button');
                        notDefendButton.className = 'game-button';
                        notDefendButton.textContent = '放弃防御并支付';
                        notDefendButton.addEventListener('click', () => this.playerDefend(defenderPlayer.id, false));
                        defendButtons.appendChild(notDefendButton);
                        
                        actionArea.appendChild(defendButtons);
                        break;
                    
                    case GAME_STATES.PAYING:
                        const payerPlayer = this.players.find(p => p.id === this.attackTarget);
                        if (!payerPlayer) break;
                        
                        const requiredCards = 1 + this.leverage;
                        const payContainer = document.createElement('div');
                        payContainer.className = 'info-box';
                        payContainer.innerHTML = `<h3>支付阶段 - 玩家 ${payerPlayer.id}</h3>
                            <p>需要支付 ${requiredCards} 张牌</p>
                            <p>请选择支付方式：</p>`;
                        actionArea.appendChild(payContainer);
                        
                        const payButtons = document.createElement('div');
                        payButtons.className = 'pay-buttons';
                        
                        // 三种支付选项
                        const cashButton = document.createElement('button');
                        cashButton.className = 'game-button';
                        cashButton.textContent = '献上现金牌';
                        cashButton.addEventListener('click', () => this.playerPay(payerPlayer.id, 'cash'));
                        payButtons.appendChild(cashButton);
                        
                        const blindButton = document.createElement('button');
                        blindButton.className = 'game-button';
                        blindButton.textContent = '让攻方盲抽';
                        blindButton.addEventListener('click', () => this.playerPay(payerPlayer.id, 'blind'));
                        payButtons.appendChild(blindButton);
                        
                        const mixedButton = document.createElement('button');
                        mixedButton.className = 'game-button';
                        mixedButton.textContent = '混合支付';
                        mixedButton.addEventListener('click', () => this.playerPay(payerPlayer.id, 'mixed'));
                        payButtons.appendChild(mixedButton);
                        
                        actionArea.appendChild(payButtons);
                        break;
                    
                    case GAME_STATES.GAME_OVER:
                        const resultContainer = document.createElement('div');
                        resultContainer.className = 'info-box';
                        resultContainer.innerHTML = '<h3>游戏结束</h3><p>感谢游玩资本杀Tiny版！</p>';
                        actionArea.appendChild(resultContainer);
                        break;
                }
            }
            
            // 处理卡片点击事件
            handleCardClick(player, cardIndex) {
                const card = player.hand[cardIndex];
                if (!card) return;
                
                switch(card.type) {
                    case 'attack':
                        // 如果是攻击卡，需要选择杠杆数量
                        if (this.currentState === GAME_STATES.PLAYING) {
                            const cashCards = player.hand.filter(c => c.type === 'cash').length;
                            if (cashCards === 0) {
                                this.playerPlayCard(player.id, cardIndex, 0);
                            } else {
                                // 创建杠杆选择界面
                                const leverageSelection = document.createElement('div');
                                leverageSelection.className = 'leverage-selection';
                                
                                for (let i = 0; i <= cashCards; i++) {
                                    const button = document.createElement('button');
                                    button.className = 'game-button';
                                    button.textContent = `使用 ${i} 张杠杆`;
                                    button.dataset.leverage = i;
                                    button.addEventListener('click', () => {
                                        this.playerPlayCard(player.id, cardIndex, i);
                                        leverageSelection.remove();
                                    });
                                    leverageSelection.appendChild(button);
                                }
                                
                                document.getElementById('action-area').appendChild(leverageSelection);
                            }
                        }
                        break;
                        
                    case 'cash':
                    case 'defense':
                        // 现金牌和防御牌可以直接弃置
                        if (this.currentState === GAME_STATES.PLAYING) {
                            this.playerPlayCard(player.id, cardIndex);
                        }
                        break;
                        
                    default:
                        if (this.currentState === GAME_STATES.PLAYING) {
                            this.playerPlayCard(player.id, cardIndex);
                        }
                        break;
                }
            }
            
            // 处理攻击目标选择
            handleAttackTarget(target) {
                if (this.currentState !== GAME_STATES.ATTACKING) {
                    return;
                }
                
                const player = this.players[this.currentPlayerIndex];
                if (!player) return;
                
                if (target === 'all') {
                    // 全局攻击所有玩家
                    this.addLog(`玩家 ${player.id} 使用 ${this.attackCard.value} 攻击所有玩家`);
                    
                    // 创建全局攻击队列
                    this.globalAttackQueue = this.players
                        .filter(p => p.id !== player.id && !p.isOut)
                        .map(p => p.id);
                    
                    // 开始处理第一个目标
                    this.nextGlobalAttackTarget();
                } else {
                    // 攻击特定玩家
                    this.attackTarget = target;
                    this.currentState = GAME_STATES.DEFENDING;
                    this.addLog(`玩家 ${player.id} 攻击玩家 ${target}`);
                    this.renderGame();
                }
            }
        }

        // 初始化游戏实例
        let game = new CapitalKillTiny().initGame(3);

        // 添加按钮事件监听
        document.getElementById('btn-start').addEventListener('click', () => {
            game.startGame();
            document.getElementById('btn-start').disabled = true;
        });

        document.getElementById('btn-new').addEventListener('click', () => {
            game = new CapitalKillTiny().initGame(3);
            document.getElementById('btn-start').disabled = false;
        });
    </script>
</body>
</html>
